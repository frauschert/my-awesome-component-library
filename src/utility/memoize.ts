/**
 * Creates a memoized version of a function that caches results based on arguments.
 * Uses a Map to store cached results keyed by a serialized version of the arguments.
 *
 * The cache key is generated by JSON.stringify, so arguments must be serializable.
 * Functions with the same serialized arguments will return the cached result.
 *
 * @template Args - Tuple type of function arguments
 * @template Result - Return type of the function
 * @param fn - The function to memoize
 * @returns A memoized version of the function with cache control methods
 *
 * @example
 * ```ts
 * const expensiveCalc = (a: number, b: number) => {
 *   console.log('Computing...');
 *   return a * b + Math.random();
 * };
 *
 * const memoized = memoize(expensiveCalc);
 * memoized(5, 10); // logs "Computing..." and returns result
 * memoized(5, 10); // returns cached result (same value)
 * memoized(5, 11); // logs "Computing..." (different args)
 *
 * memoized.cache.clear(); // Clear all cached results
 * memoized.cache.delete([5, 10]); // Clear specific cached result
 * memoized.cache.has([5, 10]); // Check if result is cached
 * ```
 */
export function memoize<Args extends readonly unknown[], Result>(
    fn: (...args: Args) => Result
): ((...args: Args) => Result) & {
    cache: {
        get: (args: Args) => Result | undefined
        set: (args: Args, value: Result) => void
        has: (args: Args) => boolean
        delete: (args: Args) => boolean
        clear: () => void
        size: () => number
    }
} {
    const cache = new Map<string, Result>()

    const memoized = (...args: Args): Result => {
        const key = JSON.stringify(args)

        if (cache.has(key)) {
            // Safe to cast because we just checked has()
            return cache.get(key) as Result
        }

        const result = fn(...args)
        cache.set(key, result)
        return result
    }

    // Expose cache control methods
    memoized.cache = {
        get: (args: Args) => cache.get(JSON.stringify(args)),
        set: (args: Args, value: Result) =>
            cache.set(JSON.stringify(args), value),
        has: (args: Args) => cache.has(JSON.stringify(args)),
        delete: (args: Args) => cache.delete(JSON.stringify(args)),
        clear: () => cache.clear(),
        size: () => cache.size,
    }

    return memoized
}

export default memoize
